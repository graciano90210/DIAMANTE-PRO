### Análisis de Seguridad y Rendimiento: `app/routes.py`

| Problema Detectado | Impacto Potencial | Solución Sugerida (con ejemplo de código o refactorización) | Prioridad |
| :--- | :--- | :--- | :--- |
| **Almacenamiento y Comparación de Contraseñas en Texto Plano** | **CRÍTICO:** Si la base de datos es comprometida, todas las contraseñas de los usuarios quedarán expuestas inmediatamente. Esto incumple los principios más básicos de seguridad de datos. | Implementar el hash de contraseñas utilizando una biblioteca robusta como `werkzeug.security` (ya incluida en Flask). Las contraseñas nunca deben guardarse en texto plano. | **ALTA** |
| | | **Refactorización del Login:**<br>```python<br>from werkzeug.security import check_password_hash<br><br># ... en la ruta /login<br>user = Usuario.query.filter_by(usuario=usuario).first()<br><br>if user and check_password_hash(user.password, password) and user.activo:<br>    # Login exitoso<br># ...<br>```<br>**Al guardar/actualizar usuario:**<br>```python<br>from werkzeug.security import generate_password_hash<br><br>nuevo_usuario.password = generate_password_hash(password)<br># ...<br>``` | |
| **Múltiples Consultas a la BD en un Bucle (Problema N+1)** | **Alto:** Degradación severa del rendimiento a medida que crecen los datos. La ruta `/cobro/lista` ejecuta una consulta a la tabla `Pago` por cada préstamo activo, resultando en (N+1) consultas donde N es el número de préstamos. | Optimizar la consulta para obtener todos los datos necesarios de una sola vez. Se puede usar un `LEFT JOIN` y filtrar en Python, o una subconsulta con `NOT IN`. | **ALTA** |
| | | **Refactorización de `/cobro/lista`:**<br>```python<br># Obtener IDs de préstamos que SÍ pagaron hoy<br>hoy = datetime.now().date()<br>prestamos_con_pago_hoy_ids = db.session.query(Pago.prestamo_id).filter(<br>    Pago.prestamo_id.in_([p.id for p in prestamos_activos]),<br>    func.date(Pago.fecha_pago) == hoy<br>).distinct().all()<br>prestamos_con_pago_hoy_ids = [p_id for p_id, in prestamos_con_pago_hoy_ids]<br><br># Filtrar en la aplicación<br>prestamos_sin_pago = [p for p in prestamos_activos if p.id not in prestamos_con_pago_hoy_ids]<br>```<br>Esta solución reduce N+1 consultas a solo 2. | |
| **Falta de paginación en listados principales** | **Alto:** Consumo excesivo de memoria y tiempos de carga muy lentos en rutas como `/clientes` y `/prestamos` si el número de registros es grande. Traer todos los resultados con `.all()` no es escalable. | Implementar paginación en las consultas de la base de datos para cargar los datos en lotes (ej. 20-50 por página). | **ALTA** |
| | | **Ejemplo en `/clientes_lista`:**<br>```python<br># Obtener el número de página de los argumentos de la URL, default 1<br>page = request.args.get('page', 1, type=int)<br><br># Reemplazar .all() con .paginate()<br>clientes_paginados = Cliente.query.order_by(Cliente.fecha_registro.desc()).paginate(<br>    page=page, per_page=20, error_out=False<br>)<br><br># Pasar 'clientes_paginados' al template y renderizar los controles de paginación.<br># El objeto contiene .items, .has_next, .has_prev, .page, .pages, etc.<br>return render_template('clientes_lista.html', clientes=clientes_paginados, ...)<br>``` | |
| **Exposición de Mensajes de Error Detallados al Cliente** | **Medio:** Fuga de información sensible sobre la arquitectura interna, rutas de ficheros, consultas de base de datos o librerías utilizadas, lo cual puede facilitar ataques dirigidos. | En los bloques `except Exception as e:`, registrar el error detallado para depuración (`app.logger.error(e)`) pero mostrar un mensaje genérico al usuario final. | **MEDIA** |
| | | **Refactorización en `clientes_guardar`:**<br>```python<br>except Exception as e:<br>    db.session.rollback()<br>    app.logger.error(f"Error al guardar cliente: {str(e)}") # Log para el desarrollador<br>    return render_template('clientes_nuevo.html', <br>                         error='Ocurrió un error inesperado al guardar el cliente.', # Mensaje para el usuario<br>                         ...<br>                         )<br>``` | |
| **Ausencia de Protección contra CSRF (Cross-Site Request Forgery)** | **Medio:** Un atacante podría crear un sitio web malicioso que, al ser visitado por un administrador autenticado, realice acciones no deseadas en su nombre (ej. crear usuarios, modificar datos) sin su conocimiento. | Integrar `Flask-WTF` para generar y validar tokens CSRF en todos los formularios que realizan cambios de estado (POST, PUT, DELETE). | **MEDIA** |
| | | **Solución (requiere instalar `Flask-WTF`):**<br>1. Inicializar la extensión: `from flask_wtf.csrf import CSRFProtect; csrf = CSRFProtect(app)`<br>2. En los formularios del template, añadir: `{{ form.csrf_token }}` o `<input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/>`<br>La librería se encarga de la validación automáticamente. | |
| **Control de Acceso Roto a Nivel de Objeto (IDOR)** | **Medio:** Un usuario con un rol de bajo privilegio (ej. 'cobrador') podría acceder o modificar recursos que no le pertenecen (ej. un cliente de otra ruta) simplemente adivinando el ID en la URL (ej. `/clientes/editar/<ID_de_otro>`). | En cada ruta que maneja un objeto específico por ID, añadir una segunda validación para asegurar que el usuario actual tiene permiso sobre *ese objeto en particular*. | **MEDIA** |
| | | **Ejemplo en `/clientes_editar/<cliente_id>`:**<br>```python<br>cliente = Cliente.query.get_or_404(cliente_id)<br>rol = session.get('rol')<br><br>if rol == 'cobrador':<br>    # Verificar si este cliente pertenece al cobrador<br>    prestamo_del_cobrador = Prestamo.query.filter_by(cliente_id=cliente.id, cobrador_id=session.get('usuario_id')).first()<br>    if not prestamo_del_cobrador:<br>        flash('Acceso no autorizado a este cliente.')<br>        return redirect(url_for('clientes_lista'))<br><br># Si pasa la validación, continuar a renderizar el template<br>return render_template('clientes_editar.html', ...)<br>``` | |
| **Generación de Imágenes Síncrona en el Hilo Principal** | **Bajo/Medio:** La generación de comprobantes en imagen (`/prestamos/comprobante-imagen/...`) es una operación que consume CPU. Si se solicitan muchos a la vez, puede bloquear el servidor y aumentar la latencia para todas las demás peticiones. | Para aplicaciones con alto tráfico, esta tarea debería ser delegada a un trabajador en segundo plano (ej. Celery, RQ) que genere la imagen y la guarde en un almacenamiento (ej. S3), devolviendo la URL al usuario. | **BAJA** |
| | | **Concepto de refactorización (con Celery):**<br>```python<br># En routes.py<br>from .tasks import generar_comprobante_task<br><br>@app.route('/generar-comprobante-async/<int:prestamo_id>')<br>def generar_comprobante_async(prestamo_id):<br>    task = generar_comprobante_task.delay(prestamo_id)<br>    return jsonify({'task_id': task.id}), 202 # Devolver ID de la tarea<br><br># En tasks.py (trabajador Celery)<br>@celery.task<br>def generar_comprobante_task(prestamo_id):<br>    # ... lógica para crear la imagen y guardarla en S3 o disco ...<br>    return "URL_de_la_imagen"<br>``` | |
